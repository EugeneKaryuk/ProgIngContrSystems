# monorepo



# Understanding Monorepos 

https://monorepo.tools/

Monorepos зараз дуже популярний, особливо серед веб-розробників. Ми створили цей ресурс, щоб допомогти розробникам зрозуміти, що таке монорепо, які переваги вони можуть принести, а також доступні інструменти, щоб зробити розробку монорепо чудовою.

Є багато чудових інструментів monorepo, створених великими командами з різними філософіями. Ми докладаємо всіх зусиль, щоб об’єктивно представити кожен інструмент, і [ми вітаємо запити на витягування, якщо щось не так!](https://github.com/nrwl/monorepo.tools?utm_source=monorepo.tools)

Інструменти, на яких ми зосередимося, це: [Bazel (від Google)](https://bazel.build/?utm_source=monorepo.tools), [Інструмент збірки Gradle (від Gradle, Inc)](https://gradle .org/?utm_source=monorepo.tools), [Lage (від Microsoft)](https://microsoft.github.io/lage/?utm_source=monorepo.tools), [Lerna](https://lerna.js .org/?utm_source=monorepo.tools), [moon (від moonrepo)](https://moonrepo.dev/moon/?utm_source=monorepo.tools), [Nx (від Nrwl)](https://nx .dev/?utm_source=monorepo.tools), [Pants (від спільноти Pants Build)](https://pantsbuild.org/?utm_source=monorepo.tools), [Rush (від Microsoft)](https:// rushstack.io/?utm_source=monorepo.tools) і [Turborepo (від Vercel)](https://turborepo.org/?utm_source=monorepo.tools). Ми обрали ці інструменти через їх використання або визнання в спільноті веб-розробників.

Давайте визначимо, що ми та інші зазвичай маємо на увазі, коли говоримо про Monorepos.

Монорепо — це єдине сховище, що містить кілька окремих проектів із чітко визначеними зв’язками.

Ми в Nrwl вважаємо, що це найбільш послідовне та точне твердження про те, що таке монорепо серед усіх усталених інструментів монорепо.

![monorepo vs polyrepo](https://monorepo.tools/images/monorepo-polyrepo.svg)

Не просто «розміщення коду»

Розглянемо сховище з кількома проектами в ньому. У нас безперечно є «колокація коду», але якщо між ними немає чітко визначених зв’язків, ми б не називали це монорепо.

Так само, якщо репозиторій містить масивну програму без поділу та інкапсуляції окремих частин, це просто велике репо. Ви можете дати йому химерну назву, як-от «garganturepo», але, на жаль, це не монорепо.

Насправді таке репо є надзвичайно монолітним, і це часто перше, що спадає на думку, коли люди думають про монорепо. Продовжуйте читати, і ви побачите, що хороший monorepo є протилежністю монолітному.

![monolith vs modular](https://monorepo.tools/images/monolith-modular.svg)

Monorepo ≠ is different from Monolith

Гарне монорепо – це протилежність монолітному! Докладніше про це та інші хибні уявлення читайте в статті [«Неправильні уявлення про Monorepos: Monorepo != Monolith»](https://blog.nrwl.io/misconceptions-about-monorepos-monorepo-monolith-df1250d4b03c).

# Polyrepo

Заради цієї дискусії, скажімо, протилежністю monorepo є "polyrepo". Полірепо — це поточний стандартний спосіб розробки програм: репо для кожної команди, програми чи проекту. І зазвичай кожне репо має один артефакт збірки та простий конвеєр збірки.

![polyrepo practice](https://monorepo.tools/images/polyrepo-practice.svg)

Індустрія перейшла до способу виконання завдань polyrepo з однієї важливої причини: **автономія команди**. Команди хочуть приймати власні рішення щодо того, які бібліотеки вони використовуватимуть, коли вони розгортатимуть свої програми чи бібліотеки, а також хто може робити внесок у їхній код або використовувати його.

![spectrum real world](https://monorepo.tools/images/spectrum-real-world.svg)

Це все добре, тож чому команди повинні робити щось інакше? Тому що ця автономія забезпечується ізоляцією, а ізоляція шкодить співпраці. Точніше, це загальні недоліки середовища polyrepo:

## Громіздкий обмін кодом

Щоб поділитися кодом між сховищами, ви, імовірно, створите репозиторій для спільного коду. Тепер вам потрібно налаштувати інструменти та середовище CI, додати комітери до сховища та налаштувати публікацію пакетів, щоб інші сховища могли залежати від цього. І давайте не будемо починати узгоджувати несумісні версії сторонніх бібліотек між сховищами...

## Значне дублювання коду

Ніхто не хоче клопоту з налаштуванням спільного репо, тому команди просто пишуть власні реалізації загальних служб і компонентів у кожному репо. Це втрачає попередній час, але також збільшує навантаження на технічне обслуговування, безпеку та контроль якості, оскільки змінюються компоненти та послуги.

## Дорогі крос-репо зміни спільних бібліотек і споживачів

Розглянемо критичну помилку або критичну зміну в спільній бібліотеці: розробнику потрібно налаштувати своє середовище для застосування змін до кількох сховищ із відключеною історією версій. Не кажучи вже про координацію версій і випуск пакетів.

## Непослідовний інструментарій

Кожен проект використовує власний набір команд для запуску тестів, створення, обслуговування, лінінгування, розгортання тощо. Неузгодженість створює розумові накладні витрати на запам’ятовування, які команди використовувати від проекту до проекту.

# Monorepo

Працюючи в polyrepo, ми можемо опинитися в досить складних ситуаціях. Але як монорепо може допомогти вирішити їх усі?

## Ніяких накладних витрат на створення нових проектів

Використовуйте наявні налаштування CI, і не потрібно публікувати пакети з версіями, якщо всі споживачі знаходяться в одному репо.

## Atomic зобов'язує проекти

Усе працює разом у кожному коміті. Немає такого поняття, як критична зміна, коли ви виправляєте все в одному коміті.

## Одна версія всього

Не потрібно турбуватися про несумісність через проекти, що залежать від конфліктних версій сторонніх бібліотек.

## Мобільність розробника

Отримайте послідовний спосіб створення та тестування програм, написаних з використанням різних інструментів і технологій. Розробники можуть впевнено робити внесок у програми інших команд і перевіряти, чи їхні зміни безпечні.

Monorepos має багато переваг, але щоб вони працювали, потрібно мати відповідні інструменти. У міру того як ваш робочий простір росте, інструменти повинні допомагати вам підтримувати його швидкістю, зрозумілістю та керованістю.

Справа не лише в характеристиках.

Особливості мають значення! Такі речі, як підтримка розподіленого виконання завдань, можуть змінити правила гри, особливо у великих моносховищах. Але є й інші надзвичайно важливі речі, такі як ергономіка, зрілість, документація, підтримка редакторів тощо. Ми не розглядаємо їх тут, оскільки вони більш суб’єктивні.

Вам може здатися, скажімо, Lage більш приємним у використанні, ніж Nx або Bazel, хоча в деяких аспектах він менш спроможний.

Деякі функції легко додати, навіть якщо даний інструмент не підтримує їх (наприклад, генерація коду), а деякі насправді неможливо додати (наприклад, розподілене виконання завдань).