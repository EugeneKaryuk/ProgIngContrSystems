**Програмна інженерія в системах управління. Лекції.** Автор і лектор: Олександр Пупена 

[<-- Частина 1](python.md)  [до лекцій](README.md)  

# Основи Python Ч2

https://www.w3schools.com/python/default.asp

https://pythonguide.rozh2sch.org.ua/

## Основи роботи з об'єктами

Python є об'єктно-орієнтованою мовою програмування. Майже все в Python є об’єктом зі своїми властивостями та методами. Клас схожий на конструктор об’єктів або «схему» для створення об’єктів. Клас вказує на поведінку, а об'єкт створений на базі цього класу веде себе згідно цієї поведінки та має свої дані.

```python
class MyClass:
  x = 5
p1 = MyClass()
print(p1.x)
```

Можна змінювати добавляти та видаляти властивості об'єкту, та видаляти весь об'єкт.

```python
class MyClass:
  x = 5
p1 = MyClass()
p1.x = 20
p1.y = 'New property'
print(p1.x, p1.y) # 20 New property
del p1.x # виадлити властивість
del p1 # виадлити об'єкт
```



### Функція `__init__()` та параметр `self`

Усі класи мають функцію під назвою `__init__()`, яка завжди виконується, коли клас ініціюється. Тобто функція викликається автоматично щоразу, коли клас використовується для створення нового об’єкта. Використовуйте функцію `__init__()`, щоб призначити значення властивостям об’єкта або іншим операціям, які необхідно виконувати під час створення об’єкта:

```python
class Person:
  def __init__(self, name, age):
    #створення властивстей
    self.name = name 
    self.age = age

  def myfunc(self):
    print("Hello my name is " + self.name)

p1 = Person("John", 36)
p1.myfunc() 
```

Параметр `self` є посиланням на поточний екземпляр класу та використовується для доступу до змінних, які належать класу. Його не обов’язково називати `self`, ви можете називати його як завгодно, але він має бути першим параметром будь-якої функції в класі:

### Наслідування та функція `super()`

Наслідування дозволяє нам визначити клас, який успадковує всі методи та властивості від іншого класу. Батьківський клас — це клас, який успадковується, також називається базовим класом. Дочірній клас — це клас, який успадковує від іншого класу, який також називають похідним класом. Будь-який клас може бути батьківським класом, тому синтаксис такий же, як і для будь-якого іншого класу. Щоб створити клас, який успадковує функції від іншого класу, надішліть батьківський клас як параметр під час створення дочірнього класу. Python також має функцію `super()`, яка повертає батьківський клас.

```python
class Person: #означення батьківскього класу
  def __init__(self, fname, lname): # функція ініціалізації
    self.firstname = fname
    self.lastname = lname
  def printname(self): # self - свій об'єкт
    print(self.firstname, self.lastname)

class Student(Person): #означення дочірнього класу, наслідування від Person
  def __init__(self, fname, lname, year): # переозначення своєї функції ініціалізації
    super().__init__(fname, lname) # викликати батьківську (super) функцію ініціалізації 
    # Person.__init__(self, fname, lname) - альтернативний варіант
    self.graduationyear = year #добавили нову валстивість
  def welcome(self): #добавили новий метод 
    print("Welcome", self.firstname, self.lastname, "to the class of ", 		self.graduationyear)
    
x = Person("John", "Doe")
y = Student("Mike", "Olsen", 2000)
x.printname() #John Doe 
y.printname() #Mike Olsen
y.welcome () #Welcome Mike Olsen to the class of  2000
```

У прикладі вище, клас `Student` наслідував усі властивості та методи класу`Person`, та включив додаткову властивість `graduationyear` та метод `welcome`.

Якщо ви додаєте метод до дочірнього класу з тим же ім’ям, що й функція в батьківському класі, успадкування батьківського методу буде перевизначено, тобто замінено на свою версію.

### Ітератори, методи `iter`, `next`

У Python ітератор — це об’єкт, який реалізує протокол ітератора, який складається з методів `__iter__()` і `__next__()`. Це дає можливість перебирати елементи в об'єкті з використанням методу `next` за умови ініціалізації ітератору методом `iter`. Також ітератори дають можливість використовувати оператори `for`. 

Щоб створити об’єкт/клас як ітератор, вам потрібно реалізувати методи `__iter__()` і `__next__()` для вашого об’єкта.

Списки, кортежі, словники та множини є ітерованими об’єктами. Це ітеровані контейнери, з яких можна отримати ітератор. Усі ці об’єкти мають метод `iter()`, який використовується для отримання ітератора:

```python
mytuple = ("apple", "banana", "cherry")
myit = iter(mytuple) #отримати ітератор
print(next(myit))#apple
print(next(myit))#banana
print(next(myit))#cherry
```

У методі `__iter__()` ви можете виконувати операції (ініціалізацію тощо), але завжди повинні повертати сам об’єкт ітератора. Метод `__next__()` також дозволяє вам виконувати операції та повинен повертати наступний елемент у послідовності.  Щоб ітерація не тривала вічно, иожна використати оператор `StopIteration`.

```python
class MyNumbers:
  def __iter__(self): #ініціювання ітератора
    self.a = 1
    return self

  def __next__(self): #означення методу next
    if self.a <= 3: 
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration # завершення 
myclass = MyNumbers()
myiter = iter(myclass) #інціювання ітератора
for x in myiter: #перебір елементів
  print(x) # виведе 1 2 3
```

## Модулі

Розглядайте модуль як бібліотеку коду, тобто файл, що містить набір функцій, які ви хочете включити у свою програму. 

### Власні модулі

Щоб створити модуль, просто збережіть потрібний код у файлі з розширенням `.py`.

```python
def greeting(name):
  print("Hello, " + name)
person1 = {
  "name": "John",
  "age": 36,
  "country": "Norway"
} 
```

Тепер ми можемо використовувати щойно створений модуль за допомогою оператора `import`. У разі використання функції з модуля використовуйте синтаксис: `ім’я_модуля.ім’я_функції`. Аналогічно йде звернення до змінних модуля.

```python
import mymodule
mymodule.greeting("Jonathan") # Hello, Jonathan
a = mymodule.person1["age"]
print(a) # 36 
```

Ви можете створити псевдонім, коли імпортуєте модуль, використовуючи ключове слово `as`:

```python
import mymodule as mx
a = mx.person1["age"]
print(a) 
```

### Вбудовані модулі Python

У Python є кілька вбудованих модулів, які ви можете імпортувати будь-коли. Наприклад, є вбудований модуль `platform` який можна використовувати для отримання різноманітної системної інформації ([деталі](https://docs.python.org/3/library/platform.html)). 

```python
import platform
x = platform.system()
print(x) # Windows
```

Опис стандартної бібліотеки доступний [за посиланням](https://docs.python.org/3/library/index.html).

### Перегляд змінних та функцій модуля `dir()`

Для всіх модулів, а також тих, які ви створюєте самостійно можна використовувати функцію `dir()`, яка перераховує всіх імена функцій (або імен змінних) у модулі. 

```python
import mymodule
x = dir(mymodule)
print(x) # ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'greeting', 'person1']
```

### Частковий імпорт 

Ви можете імпортувати лише частини модуля за допомогою ключового слова `from`. Тоді в посиланні вже не треба вказувати ім'я модуля, а лише ім'я імпортованого елементу

```python
from mymodule import person1 #імпортується тільки змінна person1
print (person1["age"])
```

## Дата  та час - модуль `datetime` 

## Модуль `math` 

## Модуль `json`

## Регулярні вирази `re`

## Менеджер пакунків `PIP`

PIP — це менеджер пакунків для встановлення, видалення модулів Python. Пакунки містить усі файли, необхідні для модуля. Працювати з pip у Windows можна через командний рядок безпосередньо з місця його розміщення або через опцію виклику pyhon. Нижче наведені обидва способи  

#### Запуск з папки розміщення

Для запуску pip необхідно в командному рядку перейти до його розміщення, яке можна дізнатися, викликавши в командному рядку Windows таку команду: 

```bash
py -c "import os, sys; print(os.path.dirname(sys.executable))" 
```

Далі необхідно перейти в командному рядку на його розміщення, наприклад:

```bash
cd C:\Users\username\AppData\Local\Programs\Python\Python310\Scripts
```

Перевірка версії PIP:

```bash
pip --version
```

#### Робота через параметр -m

Альтернативним способом є використання параметру `-m` при виклику `python`, який виконує бібліотеку. Наприклад, перевірити версію можна наступним викликом:

```bash
py -m pip --version
```

#### Робота з pip

Для завантаження пакунків використовується команда `install`. Наприклад:

```bash
py -m pip install camelcase
```

Після цього можна імпортувати модуль

```python
import camelcase
c = camelcase.CamelCase()
txt = "hello world"
print(c.hump(txt)) #Hello World
```

Так само можна оновити версію pip

```bash
py -m pip install --upgrade pip 
```

Пакунки можна шукати на [репозиторії](https://pypi.org/)

Видалення пакунків робиться через `uninstall`

```bash
py -m pip uninstall camelcase
```

Використовуйте команду `list`, щоб отримати список усіх пакетів, встановлених у вашій системі:

```bash
py -m pip list
```

Перевірити версію встановленого пакунку можна через опцію `show`:

```bash
py -m pip show numpy
```



## Обробка винятків



## Запитання для самоперевірки



[<-- Частина 1](python.md)  [до лекцій](README.md)  